\chapter{Introduction}

% - 3-4 pages
% - why is the thesis relevant, what is the problem/task
%   - context
%   - scientific importance / motivation / relevance
%   - goal, at least one research question
% - not too technical
% - introduce to structure of thesis (which chapters are to be expected)

%%%%% start writing here

% motivation == vision
% ... it started with a vision from star treck ...

% story
Todays distributed applications do not scale in the range of tens or hundreds of nodes but in tens of thousands \cite{distributed_systems_concepts}, \cite{cluster_computing_whitepaper} \cite{kubernetes_15000_nodes}. To be as fast and efficient as possible, the number of nodes has to automatically scale up and down based on their usage. The conditions are simple (for example \textquote{add a node when the average CPU-load of all nodes exceeds 80 percent}) but the frequency for triggers is high. To simplify the management of nodes for both the cluster software and administrations, each of the nodes should be set up the same way. A perfect use case for automation.
\newline
The process of software-defining infrastructure is called \gls{iacacr}. Using software development tools to manage infrastructure has many more advantages like version control, collaboration, reviews, automated tests, and continuous deployment. The accompanying combination of development and operations called DevOps opened a completely new field in computer science \cite{bachelor_thesis}. To be able to increase the number of components that can be software-defined, the underlying hardware needs to support it. As an example, processors have a fixed architecture, while with \gls{fpgaacr} chips it is configurable.

% why textual languages are popular for computer science:
% - easy to edit (cut, copy, paste)
% - easy to create parsers and reuse existing SE tools
% - accessible with console-based tools
% - single input type; can be worked on with only using the keyboard
% - compare and merge
% - version control
% - no special tools needed (only simple text editor)
% - can be supported by IDEs
% bad:
% - complex dependencies hard to recognize

Such hardware features are exposed via a corresponding \gls{apiacr}. Some hardware properties cannot be changed via software - for example, how many physical machines exist in a certain environment. Abstraction layers like virtualization provide a partial solution for such cases.
\newline
But virtualization only provides an \gls{apiacr} on a single host; To be scalable and to be able to distribute new workloads efficiently (for example putting a new \gls{vmacr} on the hypervisor with the lowest load), an orchestrating software is needed. Examples of such software are VMware's vSphere, OpenStack but also (formerly Google's) Kubernetes.
\newline
These tools are capable of automatic live-migrations of workloads like \gls{vmacr}s to distribute the load more equally and provide \gls{apiacr}s for their features.
\newline
Another category for such orchestrators is public cloud providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. They as well provide \gls{apiacr}s for their features.
\newline
While these \gls{apiacr}-providers allow their users to have a simplified view on provisioning, they just shift the effort of managing the underlying hardware from application developers to the provider software. It is now the responsibility of the developer team of the latter to manage the underlying hardware (like adding new physical machines to the cluster).
\newline
This approach has three main issues: For one, application developers have a hard time switching between or even mixing those providers, since their \gls{apiacr}s are very different and therefore incompatible. Second, these orchestrators all do mostly the same thing, but with different efficiency and flexibility. Third, each one of them has one initial requirement: Someone has to do the initial bootstrapping or more specifically set up the orchestrator. Again, this does not solve the hardware management problem but shifts it to a different problem which (hopefully) requires less effort to solve.
\newline
This thesis aims at three fundamental questions: Can bare-metal machines be deployed on-demand like virtual workloads on providers? Is it possible to do so without the requirement of an always-on operator, thus removing the initial bootstrapping effort? And last but not least, how can hardware constraints be mirrored in \gls{iacacr} languages?
\newline
The paper at hand first explains how workload provisioning historically evolved and introduces terms required to understand the topic. Then it describes the current state of the art of \gls{iacacr} and provisioning to identify issues and where compatibility makes the most sense. Afterward, different languages to describe \gls{iacacr} will be compared and the best fitting one selected.
Before the architecture of a reference implementation of such a tool can be discussed, the final constraints and goals for it will be determined. Finally, the results are analyzed, so the questions from above can be answered.
